package main

import (
	"io"
	"strings"

	. "github.com/davelondon/jennifer/jen"
)

func Render(w io.Writer) error {
	file := NewFile("jen")

	file.Comment("\tThis file is generated by genjen - do not edit!\n")
	file.Line()

	// For each method on *Statement, this this generates a package level
	// function and a method on *Group, both with the same name.
	redirect := func(
		name string,
		comment *Statement,
		param *Statement,
		call *Statement,
	) {
		/*
			// {comment}
			func {name}({params}) *Statement {
				return newStatement().{name}({call})
			}
		*/
		file.Add(comment)
		file.Func().Id(name).Params(param).Op("*").Id("Statement").Block(
			Return(
				Sel(
					Id("newStatement").Call(),
					Id(name).Call(call),
				),
			),
		)
		/*
			// {comment}
			func (g *Group) {name}({params}) *Statement {
				s := {name}({call})
				g.items = append(g.items, s)
				return s
			}
		*/
		file.Add(comment)
		file.Func().Params(
			Id("g").Op("*").Id("Group"),
		).Id(name).Params(param).Op("*").Id("Statement").Block(
			Id("s").Op(":=").Id(name).Params(call),
			Sel(Id("g"), Id("items")).Op("=").Append(Sel(Id("g"), Id("items")), Id("s")),
			Return(Id("s")),
		)
	}

	for _, b := range Groups {
		b := b // b used in closures
		if b.Name == "" {
			continue
		}
		comment := Commentf("%s inserts %s", b.Name, b.Desc)

		var variadic Code
		if b.List {
			variadic = Op("...")
		}
		param := Id("c").Add(variadic).Id("Code")
		call := Id("c").Add(variadic)

		redirect(
			b.Name,
			comment,
			param,
			call,
		)

		/*
			// {comment}
			func (s *Statement) {Name}(c [...]Code) *Statement {
				g := &Group{
					items:     []Code{c}|c,
					open:      "{Open}",
					close:     "{Close}",
					separator: "{Separator}",
				}
				*s = append(*s, g)
				return s
			}
		*/
		file.Add(comment)
		file.Func().Params(
			Id("s").Op("*").Id("Statement"),
		).Id(b.Name).Params(
			param,
		).Op("*").Id("Statement").Block(
			Id("g").Op(":=").Op("&").Id("Group").Dict(map[Code]Code{
				Id("items"): Do(func(s *Statement) {
					if b.List {
						s.Id("c")
					} else {
						s.Index().Id("Code").Values(Id("c"))
					}
				}),
				Id("open"):      Lit(b.Open),
				Id("close"):     Lit(b.Close),
				Id("separator"): Lit(b.Separator),
			}),
			Op("*").Id("s").Op("=").Append(Op("*").Id("s"), Id("g")),
			Return(Id("s")),
		)

		funcParam := Id("f").Func().Params(Op("*").Id("Group"))
		funcCall := Id("f")

		if b.List {
			funcName := b.Name + "Func"
			redirect(
				funcName,
				comment,
				funcParam,
				funcCall,
			)

			/*
				// {comment}
				func (s *Statement) {NameFunc}(f func(*Group)) *Statement {
					g := &Group{
						open:      "{Open}",
						close:     "{Close}",
						separator: "{Separator}",
					}
					f(g)
					*s = append(*s, g)
					return s
				}
			*/
			file.Add(comment)
			file.Func().Params(
				Id("s").Op("*").Id("Statement"),
			).Id(funcName).Params(
				funcParam,
			).Op("*").Id("Statement").Block(
				Id("g").Op(":=").Op("&").Id("Group").Dict(map[Code]Code{
					Id("open"):      Lit(b.Open),
					Id("close"):     Lit(b.Close),
					Id("separator"): Lit(b.Separator),
				}),
				Id("f").Call(Id("g")),
				Op("*").Id("s").Op("=").Append(Op("*").Id("s"), Id("g")),
				Return(Id("s")),
			)
		}
	}

	type tkn struct {
		name      string
		cap       string
		tokenType string
		tokenDesc string
	}
	tokens := []tkn{}
	for _, v := range Identifiers {
		tokens = append(tokens, tkn{
			name:      v,
			cap:       strings.ToUpper(v[:1]) + v[1:],
			tokenType: "identifierToken",
			tokenDesc: "identifier",
		})
	}
	for _, v := range Keywords {
		tokens = append(tokens, tkn{
			name:      v,
			cap:       strings.ToUpper(v[:1]) + v[1:],
			tokenType: "keywordToken",
			tokenDesc: "keyword",
		})
	}

	for _, t := range tokens {
		t := t // used in closures
		comment := Commentf(
			"%s inserts the %s %s",
			t.cap,
			t.name,
			t.tokenDesc,
		)
		redirect(
			t.cap,
			comment,
			nil,
			nil,
		)

		/*
			// {comment}
			func (s *Statement) {Name}() *Statement {
				t := token{
					typ:     {identifierToken|keywordToken},
					content: "{Name}",
				}
				*s = append(*s, t)
				return s
			}
		*/
		file.Add(comment)
		file.Func().Params(
			Id("s").Op("*").Id("Statement"),
		).Id(t.cap).Params().Op("*").Id("Statement").Block(
			Id("t").Op(":=").Id("token").Dict(map[Code]Code{
				Id("typ"):     Id(t.tokenType),
				Id("content"): Lit(t.name),
			}),
			Op("*").Id("s").Op("=").Append(Op("*").Id("s"), Id("t")),
			Return(Id("s")),
		)
	}

	for _, f := range Functions {
		f := f // used in closure
		capName := strings.ToUpper(f[:1]) + f[1:]
		comment := Commentf(
			"%s inserts the built in function %s",
			capName,
			f,
		)
		param := Id("c").Op("...").Id("Code")
		call := Id("c").Op("...")

		redirect(
			capName,
			comment,
			param,
			call,
		)

		/*
			// {comment}
			func (s *Statement) {Name}(c ...Code) *Statement {
				return s.Id("{Name}").Call(c...)
			}
		*/
		file.Add(comment)
		file.Func().Params(
			Id("s").Op("*").Id("Statement"),
		).Id(capName).Params(
			param,
		).Op("*").Id("Statement").Block(
			Return(
				Sel(
					Id("s"),
					Id("Id").Call(Lit(f)),
					Id("Call").Call(Id("c").Op("...")),
				),
			),
		)
	}

	return file.Render(w)
}
