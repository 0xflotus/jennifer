package main

import (
	"bytes"
	"io/ioutil"
	"strings"
	"text/template"

	"github.com/davelondon/jennifer/jen/data"
)

func main() {
	// TODO: convert to jen when bootstrapped
	tmpl, err := template.New("test").Funcs(template.FuncMap{
		"capital": func(s string) string {
			return strings.ToUpper(s[:1]) + s[1:]
		},
	}).Parse(`
	package jen

	/*
		This file is generated by genjen - do not edit!
	*/

	{{ range .Blocks }}
	{{ if ne .Name "" }}
	// {{ .Name }} inserts {{ .Desc }}
	func {{ .Name }}(code ...Code) *Group {
		return newStatement().{{ .Name }}(code...)
	}

	// {{ .Name }} inserts {{ .Desc }}
	func (g *Group) {{ .Name }}(c ...Code) *Group {
		if startNewStatement(g.syntax) {
			s := {{ .Name }}(c...)
			g.items = append(g.items, s)
			return s
		}
		s := Group{
			syntax: {{ .Syntax }},
			items:  c,
		}
		g.items = append(g.items, s)
		return g
	}
	{{ end }}
	{{ end }}

	{{ range .Identifiers }}
	func {{ . | capital }}() *Group {
		return newStatement().{{ . | capital }}()
	}

	func (g *Group) {{ . | capital }}() *Group {
		if startNewStatement(g.syntax) {
			s := {{ . | capital }}()
			g.items = append(g.items, s)
			return s
		}
		t := Token{
			Group:    g,
			typ:     identifierToken,
			content: "{{ . }}",
		}
		g.items = append(g.items, t)
		return g
	}
	{{ end }}

	{{ range .Functions }}
	func {{ .Name | capital }}(c ...Code) *Group {
		return newStatement().{{ .Name | capital }}(c...)
	}

	func (g *Group) {{ .Name | capital }}(c ...Code) *Group {
		if startNewStatement(g.syntax) {
			s := {{ .Name | capital }}(c...)
			g.items = append(g.items, s)
			return s
		}
		return g.Id("{{ .Name }}").{{ if .NoParens }}List{{ else }}Call{{ end }}(c...)
	}
	{{ end }}

	{{ range .Keywords }}
	func {{ . | capital }}() *Group {
		return newStatement().{{ . | capital }}()
	}

	func (g *Group) {{ . | capital }}() *Group {
		if startNewStatement(g.syntax) {
			s := {{ . | capital }}()
			g.items = append(g.items, s)
			return s
		}
		t := Token{
			Group:    g,
			typ:     keywordToken,
			content: "{{ . }}",
		}
		g.items = append(g.items, t)
		return g
	}

	{{ end }}
	/*
	{{ range .Operators }}
	// {{ .Name }} inserts the {{ .Desc }} operator ({{ .Op }})
	func {{ .Name }}() *Group {
		return newStatement().{{ .Name }}()
	}

	// {{ .Name }} inserts the {{ .Desc }} operator ({{ .Op }})
	func (g *Group) {{ .Name }}() *Group {
		if startNewStatement(g.syntax) {
			s := {{ .Name }}()
			g.items = append(g.items, s)
			return s
		}
		t := Token{
			Group:   g,
			typ:     operatorToken,
			content: "{{ .Op }}",
		}
		g.items = append(g.items, t)
		return g
	}

	{{ end }}
	*/`)
	if err != nil {
		panic(err)
	}
	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, struct {
		Keywords    []string
		Identifiers []string
		Functions   []struct {
			Name     string
			NoParens bool
		}
		Blocks []struct {
			Name   string
			Syntax string
			Desc   string
		}
		Operators []struct {
			Name string
			Desc string
			Op   string
		}
	}{
		Keywords:    data.Keywords,
		Identifiers: data.Identifiers,
		Functions:   data.Functions,
		Blocks:      data.Blocks,
		Operators:   data.Operators,
	}); err != nil {
		panic(err)
	}

	if err := ioutil.WriteFile("./generated.go", buf.Bytes(), 0644); err != nil {
		panic(err)
	}

}
