package main

import (
	"bytes"
	"io/ioutil"
	"strings"
	"text/template"

	"github.com/davelondon/jennifer/jen/data"
)

func main() {
	// TODO: convert to jen when bootstrapped
	tmpl, err := template.New("test").Funcs(template.FuncMap{
		"capital": func(s string) string {
			return strings.ToUpper(s[:1]) + s[1:]
		},
	}).Parse(`
	package jen

	/*
		This file is generated by genjen - do not edit!
	*/

	{{ range .Blocks }}
	// {{ .Name }} inserts {{ .Desc }}
	func {{ .Name }}(code ...Code) *Statement {
		s := new(Statement)
		return s.{{ .Name }}(code...)
	}

	// {{ .Name }} inserts {{ .Desc }}
	func (l *StatementList) {{ .Name }}(code ...Code) *Statement {
		s := {{ .Name }}(code...)
		*l = append(*l, s)
		return s
	}

	// {{ .Name }} inserts {{ .Desc }}
	func (s *Statement) {{ .Name }}(code ...Code) *Statement {
		g := group{
			Statement: s,
			code:      code,
			{{- if ne .Open "" }}
			open:      "{{ .Open }}",
			{{- end -}}
			{{- if ne .Close "" }}
			close:     "{{ .Close }}",
			{{- end -}}
			{{- if ne .Seperator "" }}
			seperator: "{{ .Seperator }}",
			{{- end }}
		}
		*s = append(*s, g)
		return s
	}
	{{ end }}

	{{ range .Identifiers }}
	func {{ . | capital }}() *Statement {
		s := new(Statement)
		return s.{{ . | capital }}()
	}

	func (l *StatementList) {{ . | capital }}() *Statement {
		s := {{ . | capital }}()
		*l = append(*l, s)
		return s
	}

	func (s *Statement) {{ . | capital }}() *Statement {
		t := Token{
			Statement: s,
			typ:       identifierToken,
			content:   "{{ . }}",
		}
		*s = append(*s, t)
		return s
	}
	{{ end }}

	{{ range .Functions }}
	func {{ . | capital }}(c ...Code) *Statement {
		s := new(Statement)
		return s.{{ . | capital }}(c...)
	}

	func (l *StatementList) {{ . | capital }}(c ...Code) *Statement {
		s := {{ . | capital }}(c...)
		*l = append(*l, s)
		return s
	}

	func (s *Statement) {{ . | capital }}(c ...Code) *Statement {
		t := Token{
			Statement: s,
			typ:       identifierToken,
			content:   "{{ . }}",
		}
		ca := Call(c...)
		*s = append(*s, t, ca)
		return s
	}
	{{ end }}

	{{ range .Keywords }}
	func {{ . | capital }}() *Statement {
		s := new(Statement)
		return s.{{ . | capital }}()
	}

	func (l *StatementList) {{ . | capital }}() *Statement {
		s := {{ . | capital }}()
		*l = append(*l, s)
		return s
	}

	func (s *Statement) {{ . | capital }}() *Statement {
		t := Token{
			Statement: s,
			typ:       keywordToken,
			content:   "{{ . }}",
		}
		*s = append(*s, t)
		return s
	}

	{{ end }}
	
	{{ range .Operators }}
	// {{ .Name }} inserts the {{ .Desc }} operator ({{ .Op }})
	func {{ .Name }}() *Statement {
		s := new(Statement)
		return s.{{ .Name }}()
	}

	// {{ .Name }} inserts the {{ .Desc }} operator ({{ .Op }})
	func (l *StatementList) {{ .Name }}() *Statement {
		s := {{ .Name }}()
		*l = append(*l, s)
		return s
	}

	// {{ .Name }} inserts the {{ .Desc }} operator ({{ .Op }})
	func (s *Statement) {{ .Name }}() *Statement {
		t := Token{
			Statement: s,
			typ:       operatorToken,
			content:   "{{ .Op }}",
		}
		*s = append(*s, t)
		return s
	}

	{{ end }}`)
	if err != nil {
		panic(err)
	}
	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, struct {
		Keywords    []string
		Identifiers []string
		Functions   []string
		Blocks      []struct {
			Name      string
			Desc      string
			Open      string
			Close     string
			Seperator string
		}
		Operators []struct {
			Name string
			Desc string
			Op   string
		}
	}{
		Keywords:    data.Keywords,
		Identifiers: data.Identifiers,
		Functions:   data.Functions,
		Blocks:      data.Blocks,
		Operators:   data.Operators,
	}); err != nil {
		panic(err)
	}

	if err := ioutil.WriteFile("./generated.go", buf.Bytes(), 0644); err != nil {
		panic(err)
	}

}
